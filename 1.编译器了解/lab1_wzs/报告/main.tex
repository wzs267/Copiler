\documentclass[a4paper]{article}

\input{style/ch_xelatex.tex}
\input{style/scala.tex}

%代码段设置
\lstset{numbers=left,
basicstyle=\tiny,
numberstyle=\tiny,
keywordstyle=\color{blue!70},
commentstyle=\color{red!50!green!50!blue!50},
frame=single, rulesepcolor=\color{red!20!green!20!blue!20},
escapeinside=``
}

\graphicspath{ {images/} }
\usepackage{ctex}
\usepackage{graphicx}
\usepackage{color,framed}%文本框
\usepackage{listings}
\usepackage{caption}
\usepackage{amssymb}
\usepackage{enumerate}
\usepackage{xcolor}
\usepackage{bm} 
\usepackage{lastpage}%获得总页数
\usepackage{fancyhdr}
\usepackage{tabularx}  
\usepackage{geometry}
%\usepackage{minted}  % removed to avoid requiring shell-escape and speed up compilation
\usepackage{graphics}
\usepackage{subfigure}
\usepackage{float}
\usepackage{pdfpages}
\usepackage{pgfplots}
\pgfplotsset{width=10cm,compat=1.9}
\usepackage{multirow}
\usepackage{footnote}
\usepackage{booktabs}
\lstdefinelanguage{text}{}
%-----------------------伪代码------------------
\usepackage{algorithm}  
\usepackage{algorithmicx}  
\usepackage{algpseudocode}  
\floatname{algorithm}{Algorithm}  
\renewcommand{\algorithmicrequire}{\textbf{Input:}}  
\renewcommand{\algorithmicensure}{\textbf{Output:}} 
\usepackage{lipsum}  
\makeatletter
\newenvironment{breakablealgorithm}
  {% \begin{breakablealgorithm}
  \begin{center}
     \refstepcounter{algorithm}% New algorithm
     \hrule height.8pt depth0pt \kern2pt% \@fs@pre for \@fs@ruled
     \renewcommand{\caption}[2][\relax]{% Make a new \caption
      {\raggedright\textbf{\ALG@name~\thealgorithm} ##2\par}%
      \ifx\relax##1\relax % #1 is \relax
         \addcontentsline{loa}{algorithm}{\protect\numberline{\thealgorithm}##2}%
      \else % #1 is not \relax
         \addcontentsline{loa}{algorithm}{\protect\numberline{\thealgorithm}##1}%
      \fi
      \kern2pt\hrule\kern2pt
     }
  }{% \end{breakablealgorithm}
     \kern2pt\hrule\relax% \@fs@post for \@fs@ruled
  \end{center}
  }
\makeatother
%------------------------代码-------------------
\usepackage{xcolor} 
\usepackage{listings} 
\lstset{ 
breaklines,%自动换行
basicstyle=\small,
escapeinside=``,
keywordstyle=\color{ blue!70} \bfseries,
commentstyle=\color{red!50!green!50!blue!50},% 
stringstyle=\ttfamily,% 
extendedchars=false,% 
linewidth=\textwidth,% 
numbers=left,% 
numberstyle=\tiny \color{blue!50},% 
frame=trbl% 
rulesepcolor= \color{ red!20!green!20!blue!20} 
}

%-------------------------页面边距--------------
\geometry{a4paper,left=2.3cm,right=2.3cm,top=2.7cm,bottom=2.7cm}
%-------------------------页眉页脚--------------
\usepackage{fancyhdr}
\pagestyle{fancy}
\lhead{\kaishu \leftmark}
% \chead{}
\rhead{\kaishu 编译原理实验报告}%加粗\bfseries 
\lfoot{}
\cfoot{\thepage}
\rfoot{}
\renewcommand{\headrulewidth}{0.1pt}  
\renewcommand{\footrulewidth}{0pt}%去掉横线
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}%标题横线
\newcommand{\HRulegrossa}{\rule{\linewidth}{1.2mm}}
\setlength{\textfloatsep}{10mm}%设置图片的前后间距
%--------------------文档内容--------------------

\begin{document}
\renewcommand{\contentsname}{目\ 录}
\renewcommand{\appendixname}{附录}
\renewcommand{\appendixpagename}{附录}
\renewcommand{\refname}{参考文献} 
\renewcommand{\figurename}{图}
\renewcommand{\tablename}{表}
\renewcommand{\today}{\number\year 年 \number\month 月 \number\day 日}

%-------------------------封面----------------
\begin{titlepage}
    \begin{center}
    \includegraphics[width=0.8\textwidth]{NKU.png}\\[1cm]
    \vspace{20mm}
		\textbf{\huge\textbf{\kaishu{计算机学院}}}\\[0.5cm]
		\textbf{\huge{\kaishu{编译原理第一次试验}}}\\[2.3cm]
		\textbf{\Huge\textbf{\kaishu{认识编译器}}}

		\vspace{\fill}
    
    % \textbf{\Large \textbf{并行程序设计期末实验报告}}\\[0.8cm]
    % \HRule \\[0.9cm]
    % \HRule \\[2.0cm]
    \centering
    \textsc{\LARGE \kaishu{姓名\ :\ 王泽舜\ 杨乔钦}}\\[0.5cm]
    \textsc{\LARGE \kaishu{学号\ :\ 2310655\ 2311838}}\\[0.5cm]
    \textsc{\LARGE \kaishu{专业\ :\ 计算机科学与技术}}\\[0.5cm]
    
    \vfill
    {\Large \today}
    \end{center}
\end{titlepage}

\renewcommand {\thefigure}{\thesection{}.\arabic{figure}}%图片按章标号
\renewcommand{\figurename}{图}
\renewcommand{\contentsname}{目录}  
\cfoot{\thepage\ of \pageref{LastPage}}%当前页 of 总页数


% 生成目录
\clearpage
\tableofcontents
\newpage



%-------------------------Codes----------------------------------


\section{第一题：编译过程分析}

\subsection{预处理器}

预处理器是编译过程的第一阶段，主要负责处理源代码中的预处理指令，如宏定义、文件包含、条件编译等。在GCC中，预处理器由cpp工具执行。

以fibonacci.c为例，源代码包含了\#include <stdio.h>和\#define MAX\_ITERATIONS 10。预处理器会展开这些指令：将stdio.h的内容插入到代码中，替换宏定义等。生成的fibonacci.i文件就是预处理后的中间文件，其中包含了所有必要的头文件定义和宏展开，但不包含注释和预处理指令。

对比fibonacci.c和fibonacci.i：fibonacci.c中只有几行代码，而fibonacci.i包含了stdio.h的完整定义，包括函数声明如printf、putchar等。宏MAX\_ITERATIONS被替换为10。预处理器还添加了行号信息和编译器版本等元数据。

\textbf{之前（fibonacci.c的main函数部分）：}
\begin{lstlisting}[language=C]
#define MAX_ITERATIONS 10

int main() {
    int a = 0, b = 1, next, i;

    printf("Fibonacci Series up to %d terms:\n", MAX_ITERATIONS);
    
    for (i = 0; i < MAX_ITERATIONS; i++) {
        if (i <= 1) {
            next = i;
        } else {
            next = a + b;
            a = b;
            b = next;
        }
        printf("%d ", next);
    }
    printf("\n");
    return 0;
}
\end{lstlisting}

\textbf{之后（fibonacci.i的main函数部分）：}
\begin{lstlisting}[language=C]
int main() {
    int a = 0, b = 1, next, i;

    printf("Fibonacci Series up to %d terms:\n", 10);
    
    for (i = 0; i < 10; i++) {
        if (i <= 1) {
            next = i;
        } else {
            next = a + b;
            a = b;
            b = next;
        }
        printf("%d ", next);
    }
    printf("\n");
    return 0;
}
\end{lstlisting}

\subsection{编译器}

编译器将预处理后的代码转换为汇编代码。在GCC中，编译器前端（cc1）执行以下阶段：

词法分析：将源代码分解成token，如关键字（int, for, if）、标识符（main, a, b）、运算符（+, =）、常量（10）等。

语法分析：根据语法规则构建抽象语法树（AST），识别程序结构如函数定义、循环、条件语句。

语义分析：检查类型一致性、作用域等，进行类型检查和符号表构建。例如，确保变量类型匹配，函数调用正确。

中间代码生成：生成中间表示（IR），如GIMPLE或RTL。GCC使用GIMPLE作为高级IR，然后转换为RTL。

优化：进行各种优化，如常量折叠（将MAX\_ITERATIONS替换为10）、死代码消除、循环优化等。在fibonacci程序中，循环被优化为汇编中的jmp和cmp指令。

代码生成：将IR转换为目标平台的汇编代码。

从fibonacci.i到fibonacci.s，编译器生成了x86-64汇编代码。fibonacci.s包含了.text段、.rodata段（字符串常量）、main函数的汇编实现。汇编代码使用了栈来管理局部变量（如a, b, next, i），并调用printf和putchar。相比.i文件，.s文件是平台特定的机器指令序列。

\textbf{之前（fibonacci.i的main函数部分）：}
\begin{lstlisting}[language=C]
int main() {
    int a = 0, b = 1, next, i;

    printf("Fibonacci Series up to %d terms:\n", 10);
    
    for (i = 0; i < 10; i++) {
        if (i <= 1) {
            next = i;
        } else {
            next = a + b;
            a = b;
            b = next;
        }
        printf("%d ", next);
    }
    printf("\n");
    return 0;
}
\end{lstlisting}

\textbf{之后（fibonacci.s的main函数部分）：}
\begin{lstlisting}[language={[x86masm]Assembler}]
	.globl	main
	.type	main, @function
main:
.LFB0:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	subq	$16, %rsp
	movl	$0, -16(%rbp)
	movl	$1, -12(%rbp)
	movl	$10, %esi
	leaq	.LC0(%rip), %rax
	movq	%rax, %rdi
	movl	$0, %eax
	call	printf@PLT
	movl	$0, -4(%rbp)
	jmp	.L2
.L2:
\end{lstlisting}

\subsection{汇编器}

汇编器将汇编代码转换为机器码，生成目标文件（.o文件）。在GCC中，由as工具执行。

fibonacci.s文件包含了汇编指令，如mov, add, call等。汇编器将其翻译成二进制机器码，并组织成ELF格式的目标文件，包括代码段(.text)、数据段(.rodata)等。fibonacci.o.asm是目标文件的反汇编，显示了机器码（如0xf3 0f 1e fa对应endbr64）和对应的汇编指令。目标文件包含了符号表，未解析的外部符号（如printf, putchar）标记为未定义，需要链接器解决。

对比fibonacci.s和fibonacci.o.asm：.s是文本汇编，.o.asm是二进制反汇编，显示了实际的十六进制机器码和地址。

\textbf{之前（fibonacci.s的main函数部分）：}
\begin{lstlisting}[language={[x86masm]Assembler}]
	.globl	main
	.type	main, @function
main:
.LFB0:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	subq	$16, %rsp
	movl	$0, -16(%rbp)
	movl	$1, -12(%rbp)
	movl	$10, %esi
	leaq	.LC0(%rip), %rax
	movq	%rax, %rdi
	movl	$0, %eax
	call	printf@PLT
\end{lstlisting}

\textbf{之后（fibonacci.o.asm的main函数部分）：}
\begin{lstlisting}[language={[x86masm]Assembler}]
0000000000000000 <main>:
   0:	f3 0f 1e fa          	endbr64
   4:	55                   	push   %rbp
   5:	48 89 e5             	mov    %rsp,%rbp
   8:	48 83 ec 10          	sub    $0x10,%rsp
   c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)
  13:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%rbp)
  1a:	be 0a 00 00 00       	mov    $0xa,%esi
  1f:	48 8d 05 00 00 00 00 	lea    0x0(%rip),%rax        # 26 <main+0x26>
  26:	48 89 c7             	mov    %rax,%rdi
  29:	b8 00 00 00 00       	mov    $0x0,%eax
  2e:	e8 00 00 00 00       	call   33 <main+0x33>
\end{lstlisting}

\subsection{链接器}

链接器将目标文件和库链接在一起，生成可执行文件。在GCC中，由ld工具执行。

链接器解析外部符号，将目标文件中的符号引用与库中的定义匹配。对于fibonacci.o，链接器链接了libc中的printf和putchar函数，生成了可执行文件fibonacci.exe。链接器还添加了启动代码（如\texttt{\_start}函数，调用main）、PLT（Procedure Linkage Table）用于动态链接。

fibonacci.exe.asm显示了完整的可执行文件反汇编，包括.init, .plt, .text, .fini段。PLT允许延迟绑定外部函数，提高加载效率。相比.o.asm，.exe.asm包含了所有依赖的库代码和重定位信息，使程序可执行。

对比fibonacci.o.asm和fibonacci.exe.asm：.o.asm只有main函数，而.exe.asm包含了整个程序的布局，包括库函数的入口点和动态链接机制。

\textbf{之前（fibonacci.o.asm的main函数部分）：}
\begin{lstlisting}[language={[x86masm]Assembler}]
0000000000000000 <main>:
   0:	f3 0f 1e fa          	endbr64
   4:	55                   	push   %rbp
   5:	48 89 e5             	mov    %rsp,%rbp
   8:	48 83 ec 10          	sub    $0x10,%rsp
   c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)
  13:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%rbp)
  1a:	be 0a 00 00 00       	mov    $0xa,%esi
  1f:	48 8d 05 00 00 00 00 	lea    0x0(%rip),%rax        # 26 <main+0x26>
  26:	48 89 c7             	mov    %rax,%rdi
  29:	b8 00 00 00 00       	mov    $0x0,%eax
  2e:	e8 00 00 00 00       	call   33 <main+0x33>
\end{lstlisting}

\textbf{之后（fibonacci.exe.asm的main函数部分）：}
\begin{lstlisting}[language={[x86masm]Assembler}]
0000000000001169 <main>:
    1169:	f3 0f 1e fa          	endbr64
    116d:	55                   	push   %rbp
\end{lstlisting}

\subsection{编译器内部的过程}

预处理之后，编译过程进入核心阶段，代码将经历从高级抽象到低级机器指令的转变。GCC 使用了两种主要的中间表示（Intermediate Representation, IR）来完成这个过程：GIMPLE 和 RTL。

\subsubsection{词法分析：代码的“分词”}
编译器首先要像我们阅读文章一样，把一长串的源代码字符流“切分”成一个个有意义的基本单元，这些单元被称为**词法单元（Token）**。例如，`int a = 0;` 这行代码会被分解为：关键字 `int`、标识符 `a`、操作符 `=`、整型常量 `0` 和分隔符 `;`。

我们可以通过 Clang 的 `-dump-tokens` 命令得到 `tokens.txt`，其中记录了 `fibonacci.c` 被“分词”后的结果。下面是 `main` 函数开头部分的词法单元：
\begin{lstlisting}[language=text, caption={fibonacci.c 的部分词法单元 (tokens.txt)}]
int 'int'      [StartOfLine]  Loc=<fibonacci.c:5:1>
identifier 'main'      [LeadingSpace] Loc=<fibonacci.c:5:5>
l_paren '('             Loc=<fibonacci.c:5:9>
r_paren ')'             Loc=<fibonacci.c:5:10>
l_brace '{'      [LeadingSpace] Loc=<fibonacci.c:5:12>
int 'int'      [StartOfLine] [LeadingSpace] Loc=<fibonacci.c:6:5>
identifier 'a'       [LeadingSpace] Loc=<fibonacci.c:6:9>
equal '='      [LeadingSpace] Loc=<fibonacci.c:6:11>
numeric_constant '0'      [LeadingSpace] Loc=<fibonacci.c:6:13>
comma ','               Loc=<fibonacci.c:6:14>
\end{lstlisting}
每一行都清晰地标明了词法单元的类型（如 `keyword`、`identifier`）、内容（如 `'main'`）和它在源文件中的位置。

\subsubsection{语法分析：构建句法结构}
词法分析之后，编译器需要根据语言的语法规则，将离散的词法单元组织成一个具有层级结构的**抽象语法树（Abstract Syntax Tree, AST）**。这棵树精确地反映了代码的语法结构。如果代码存在语法错误（例如，`for` 循环缺少括号），这个阶段就会报错。

ast\_dump.txt 文件展示了 fibonacci.c 的 AST。树的根节点是TranslationUnitDecl（翻译单元声明），下面包含了我们定义的 main函数。
\begin{lstlisting}[language=text, caption={main 函数的抽象语法树片段 (ast\_dump.txt)}]
|-FunctionDecl 0x... <<fibonacci.c:5:1, line:22:1>> line:5:5 main 'int ()'
  `-CompoundStmt 0x... <line:5:12, line:22:1>
    |-DeclStmt 0x... <line:6:5, col:32>
    | `-VarDecl 0x... <col:5, col:9> col:9 used a 'int' cinit
    ...
    |-ForStmt 0x... <line:9:5, line:19:5>
    | |-DeclStmt 0x... <line:9:10, col:17>
    | | `-VarDecl 0x... <col:10, col:14> col:14 used i 'int' cinit
    | |-<<<NULL>>>
    | |-BinaryOperator 0x... <col:19, col:34> 'int' '<'
    ...
\end{lstlisting}
从中我们可以看到，`main` 函数 (`FunctionDecl`) 包含一个复合语句 (`CompoundStmt`)，复合语句中又有一个 `ForStmt` 节点，清晰地还原了 `for` 循环的结构。

\subsubsection{语义分析与中间代码}
在 AST 的基础上，编译器进行**语义分析**，检查代码的逻辑是否自洽。这包括类型检查（例如，不能把一个字符串赋值给整型变量）、变量是否声明后才使用等。

通过所有检查后，编译器将 AST 转换为一种更接近机器指令的**中间表示（IR）**。GCC 使用 GIMPLE 和 RTL 作为其主要的 IR。这部分在之前的章节已有详细阐述，它作为优化的主要载体，对 GIMPLE 形式的代码进行常量传播、冗余消除等操作，然后转换为更低级的 RTL，为生成最终的汇编代码做准备。

\subsubsection{GIMPLE：接近源码的高级表示}

编译器首先将预处理后的代码转换成一种名为 **GIMPLE** 的高级中间表示。GIMPLE 的设计目标是既能保留部分源代码的结构（如循环和条件），又足够简单，以便进行各种与目标机器无关的代码优化。它采用的是一种“三地址码”的形式，即每个指令最多只涉及三个操作数。

在不进行任何优化（`-O0`）的情况下，`fibonacci.c` 的 `main` 函数转换的初始 GIMPLE 代码（位于 `fibonacci.c.004t.gimple`）如下所示。可以看到，代码结构与原始 C 代码非常相似，变量定义、循环结构和函数调用都清晰可见。

\begin{lstlisting}[language=C, caption={fibonacci.c.004t.gimple}]
;; Function main (main, funcdef_no=0, decl_uid=2095, cgraph_uid=1, symbol_order=0)

main ()
{
  int next;
  int b;
  int a;
  int i;
  int D.2104;

  <bb 2> [local count: 1073741824]:
  a = 0;
  b = 1;
  printf ("Fibonacci Series up to %d terms:\n", 10);
  i = 0;
  goto <bb 4>; [100.00%]

  <bb 3> [local count: 976367641]:
  if (i <= 1)
    {
      next = i;
    }
  else
    {
      next = a + b;
      a = b;
      b = next;
    }
  printf ("%d ", next);
  i = i + 1;

  <bb 4> [local count: 1073741824]:
  if (i <= 9)
    {
      goto <bb 3>; [91.00%]
    }
  else
    {
      goto <bb 5>; [9.00%]
    }

  <bb 5> [local count: 97374183]:
  printf ("\n");
  D.2104 = 0;
  return D.2104;

}
\end{lstlisting}

\subsubsection{从接近高级语言的GIMPLE到接近机器语言的RTL}

GIMPLE 的真正威力在于它是绝大多数优化的载体。当开启优化选项（如 `-O2`）时，编译器会执行数百个优化过程（Pass），对 GIMPLE 代码进行分析和转换，以期生成更高效的代码。常见的优化手段包括：
\begin{itemize}
    \item \textbf{常量传播：} 将常量值直接替换到使用它的地方。
    \item \textbf{冗余消除：} 删除重复的计算。
    \item \textbf{循环优化：} 如循环展开、循环不变代码外提等。
    \item \textbf{函数内联：} 将小函数的调用直接替换为函数体本身。
\end{itemize}
经过 `-O2` 优化后，虽然初始 GIMPLE 变化不大，但在后续的优化传递中，代码结构会被极大改变，为生成更高效的底层代码铺平道路。

\subsubsection{RTL：面向机器的低级表示}

当 GIMPLE 阶段的优化完成后，编译器会将其转换为一种更低级的、更接近机器指令的中间表示——**RTL (Register Transfer Language)**。RTL 描述了数据如何在寄存器之间传送和计算，它为目标机器相关的优化（如指令选择和寄存器分配）提供了基础。

RTL 代码看起来更像汇编语言的抽象描述。以下是 `-O0`（未优化）和 `-O2`（优化）下 `main` 函数最终生成的 RTL 代码（位于 `*.final` 文件）的片段对比。

\textbf{未优化的 Final RTL (`-O0`)}:
代码显得冗长，频繁地在栈（`[rbp-...]`）和寄存器之间移动数据。这是因为 `-O0` 旨在直接翻译代码，而不关心性能。
\begin{lstlisting}[language=text, caption={fibonacci.c.273r.final (未优化片段)}]
(insn 15 14 16 2 (set (reg:SI 91 [ i ])
        (const_int 0 [0])) "fibonacci.c":9:5 -1
     (nil))
(jump_insn 16 15 17 2 (set (pc)
        (label_ref 29)) "fibonacci.c":9:5 -1
     (nil)
 -> 29)
(insn 22 21 23 2 (set (reg:SI 88 [ next ])
        (reg:SI 91 [ i ])) "fibonacci.c":11:13 -1
     (nil))
(jump_insn 23 22 24 2 (set (pc)
        (label_ref 27)) "fibonacci.c":11:13 -1
     (nil)
 -> 27)
\end{lstlisting}

\textbf{优化后的 Final RTL (`-O2`)}:
代码精简了许多。编译器通过优化，将许多变量直接保存在寄存器中，减少了内存访问。例如，循环计数器和斐波那契数列的值可能长时间驻留在寄存器中，大大提高了执行效率。
\begin{lstlisting}[language=text, caption={fibonacci.c.340r.final (优化片段)}]
(insn 7 6 8 2 (set (reg:SI 91)
        (const_int 1 [0x1])) "fibonacci.c":6:20 -1
     (nil))
(insn 8 7 9 2 (set (reg:SI 92)
        (const_int 0 [0])) "fibonacci.c":6:20 -1
     (nil))
(insn 9 8 10 2 (set (reg:SI 93)
        (const_int 0 [0])) "fibonacci.c":9:5 -1
     (nil))
(jump_insn 10 9 11 2 (set (pc)
        (label_ref 21)) "fibonacci.c":9:5 -1
     (nil)
 -> 21)
\end{lstlisting}

最终，这些 RTL 指令会被转换成目标平台的汇编代码，完成整个编译过程。通过观察从 GIMPLE 到 RTL 的演变，以及不同优化级别下的差异，我们可以深刻体会到编译器是如何在忠实于原始逻辑的基础上，对代码进行精雕细琢，以追求极致性能的。
\section{第二题：汇编代码撰写}

第二题中，王泽舜负责编写与源程序等价的llvm IR 代码，杨乔钦负责编写与源程序等价的riscv汇编代码。
\subsection{原始SysY程序}
我们编写了一个简单的SysY程序，功能是读取一个整数数组，计算其元素和，并根据和的大小进行不同的输出操作
如果大于20，会输出和的两倍，如果小于等于20，会输出和除以3的余数。
程序中包含了变量声明、数组操作、算术运算、条件判断和函数调用等基本语法结构。以下是该SysY程序的完整代码：
\begin{lstlisting}[title=逐列访问平凡算法,frame=trbl,language={C}]
// 全局变量和常量声明
const int N = 5;
int global_array[5] = {2,2,3,4,5};

// SysY运行时库函数声明 - 必须添加这些声明才能调用库函数
void putint(int);       // 输出一个整数
void putch(int);        // 输出一个字符

// 函数声明
int calculate(int a, int b);

int main() {

    int sum = 0;
    int i = 0;
    
    // 使用getarray从输入获取数据，替换原来的固定数组赋值
    int count = 5;

    
    // 算术运算：计算数组元素的和
    while (i < count) {  // 使用实际读取的元素个数
        sum = sum + global_array[i];
        i = i + 1;
    }
    
    // 条件判断和输出
    if (sum > 20) {
        int result = calculate(sum, 2);
    putint(result);  // 使用putint输出结果而不是直接return
    putch(10);      // 输出换行符
    } else {
        int remainder = sum % 3;
    putint(remainder); // 使用putint输出结果
    putch(10);        // 输出换行符
    }
    
    return 0;  // main函数返回0表示正常结束
}

// 函数定义：复杂计算
int calculate(int a, int b) {
    int result = 0;
    while (b > 0) {
        result = result + a;
        b = b - 1;
    }
    return result;
}\end{lstlisting}


\subsection{arm汇编程序}
我编写的arm汇编程序如下所示，该程序实现了与上述SysY程序相同的功能。它读取一个整数数组，计算其元素和，并根据和的大小进行不同的输出操作。如果和大于20，则输出和的两倍；如果和小于等于20，则输出和除以3的余数。程序中包含了变量声明、数组操作、算术运算、条件判断和函数调用等基本语法结构。
以下是该arm汇编程序的完整代码：
\begin{lstlisting}[title=逐列访问平凡算法,frame=trbl]
	.arch armv8-a ; 指定目标架构为 AArch64
	.file	"test.c" ; 源文件名信息
	.text ; 文本段开始
	.section	.text.startup,"ax",@progbits ; 启动代码段
	.align	2 ; 对齐
	.p2align 4,,11 ; 更高对齐
	.global	main ; 导出 main 符号
	.type	main, %function ; 声明 main 为函数
main: ; main 函数入口
.LFB0: ; 函数框架开始标签
	.cfi_startproc ; 调试信息开始
	adrp	x0, .LANCHOR0 ; 将 LAUNCHER 基址高位加载到 x0
	add	x1, x0, :lo12:.LANCHOR0 ; 将基址低位加到 x0 得到完整地址放 x1
	stp	x29, x30, [sp, -16]! ; 保存帧指针和返回地址并调整栈（push）
	.cfi_def_cfa_offset 16 ; 调试: 定义 CFA 偏移
	.cfi_offset 29, -16 ; 调试: x29 保存位置
	.cfi_offset 30, -8 ; 调试: x30 保存位置
	mov	x29, sp ; 设置帧指针 x29 = sp
	ldp	w0, w4, [x1] ; 从内存载入两个 32-bit 值到 w0,w4
	ldp	w3, w2, [x1, 8] ; 继续加载另外两个 32-bit 值到 w3,w2
	add	w0, w0, w4 ; 累加 w0 和 w4
	ldr	w1, [x1, 16] ; 载入第五个 32-bit 值到 w1
	add	w0, w0, w3 ; 累加 w3
	add	w0, w0, w2 ; 累加 w2
	add	w0, w0, w1 ; 累加 w1，w0 保存元素和
	cmp	w0, 20 ; 比较和与 20
	ble	.L2 ; 若小于等于 20 跳到 .L2
	lsl	w0, w0, 1 ; 否则将和乘 2（左移一位）
	bl	putint ; 调用 putint 输出整数
	mov	w0, 10 ; 将换行符 ASCII 10 放入 w0
	bl	putch ; 调用 putch 输出换行
.L3: ; 公共返回标签
	mov	w0, 0 ; 返回值置 0
	ldp	x29, x30, [sp], 16 ; 恢复 x29,x30 并释放栈空间
	.cfi_remember_state ; 调试信息：记住状态
	.cfi_restore 30 ; 恢复调试寄存器 30 信息
	.cfi_restore 29 ; 恢复调试寄存器 29 信息
	.cfi_def_cfa_offset 0 ; 恢复 CFA 偏移
	ret ; 返回调用者
.L2: ; 小于等于20的处理分支
	.cfi_restore_state ; 恢复调试状态
	mov	w1, 3 ; 将除数 3 放入 w1
	sdiv	w1, w0, w1 ; w1 = w0 / 3（商）
	add	w1, w1, w1, lsl 1 ; w1 = w1 + (w1 << 1) = 3 * 商
	sub	w0, w0, w1 ; 计算余数 w0 = w0 - 3*商
	bl	putint ; 输出余数
	mov	w0, 10 ; 设置换行字符
	bl	putch ; 输出换行
	b	.L3 ; 跳转到公共返回
	.cfi_endproc ; 结束调试信息
.LFE0: ; 函数结束标签
	.size	main, .-main ; 记录 main 大小
	.text ; 文本段（下一个函数）
	.align	2 ; 对齐
	.p2align 4,,11 ; 对齐
	.global	calculate ; 导出 calculate 符号
	.type	calculate, %function ; 声明 calculate
calculate: ; calculate 函数入口
.LFB1: ; 函数框架开始
	.cfi_startproc ; 调试开始
	mul	w0, w1, w0 ; w0 = w0 * w1（乘法实现）
	cmp	w1, 0 ; 比较参数 w1 与 0
	csel	w0, w0, wzr, gt ; 若 w1>0 返回乘积，否则返回 0
	ret ; 返回
	.cfi_endproc ; 结束调试信息
.LFE1: ; 结束标签
	.size	calculate, .-calculate ; 记录大小
	.global	global_array ; 导出全局数组
	.global	N ; 导出常量 N
	.section	.rodata ; 只读数据段
	.align	2 ; 对齐
	.type	N, %object ; 声明 N 为对象
	.size	N, 4 ; N 的大小
N: ; 常量 N 标签
	.word	5 ; N = 5
	.data ; 数据段开始
	.align	4 ; 数据对齐
	.set	.LANCHOR0,. + 0 ; 设置锚点符号
	.type	global_array, %object ; 声明全局数组
	.size	global_array, 20 ; 数组大小 20 字节
global_array: ; 全局数组标签
	.word	2 ; 元素 0 = 2
	.word	2 ; 元素 1 = 2
	.word	3 ; 元素 2 = 3
	.word	4 ; 元素 3 = 4
	.word	5 ; 元素 4 = 5
	.ident	"GCC: (Ubuntu 13.3.0-6ubuntu2~24.04) 13.3.0" ; 编译器标识
	.section	.note.GNU-stack,"",@progbits ; 指示不可执行栈

\end{lstlisting}
\subsubsection{说明}
\begin{itemize}
	\item 调用约定：AArch64 使用寄存器 x0..x7 传递前八个整型/指针参数，返回值放在 x0（32-bit 时用 w0）。被调用者保存寄存器（如 x19..x28）需在函数入口保存并在返回前恢复。
	\item 栈帧与栈保护：函数入口处通过 \texttt{sub sp, sp, \#64} 分配栈空间，编译器加入了栈保护（\texttt{\_stack\_chk\_guard} / \texttt{\_stack\_chk\_fail}）以检测栈溢出攻击。
	\item 数组寻址：编译器使用位移指令（例如 \texttt{lsl 2}）将索引乘以 4 来计算整数元素的字节偏移，从而高效访问数组元素。
	\item 循环与分支优化：简单的循环被编译为比较/分支形式；小的数学变换（例如将循环展开或用乘法替代循环）可能由编译器进行优化，如本例中 \texttt{calculate} 使用乘法和条件选择实现语义。
	\item 运行时库依赖：汇编中调用的 \texttt{putint}、\texttt{putch} 等函数由运行时库（例如 \texttt{libsysy\_aarch.a}）提供。链接时必须指定对应目标架构的静态库，否则会出现未定义引用错误。
	\item 链接建议：使用交叉链接器将汇编/目标文件与 AArch64 静态库链接，例如：
	\begin{verbatim}
aarch64-linux-gnu-gcc test_aarch64.s libsysy_aarch.a -o test_arm.out
	\end{verbatim}
	若库放在子目录则传递相对路径：\texttt{lib/..../libsysy\_aarch.a}。
	\item 架构匹配：务必确保静态库是为目标架构（AArch64）构建的；x86 构建的库无法用于 ARM 链接。
	\item 调试与反汇编：若需查看生成的可执行的真实指令或符号信息，可用 \texttt{objdump -d} / \texttt{readelf} / \texttt{nm} 等工具检查符号表与节信息。
\end{itemize}
\subsection{llvm IR程序}
王泽舜编写的llvm IR程序如下所示，该程序实现了与上述SysY程序相同的功能。
以下是该llvm IR程序的完整代码，说明见注释：
\begin{lstlisting}[language=text,caption={test\_new.ll}]
; 目标平台信息，消除编译警告
target triple = "x86_64-pc-linux-gnu"
; 全局常量和数组
@N = constant i32 5
@global_array = global [5 x i32] [i32 2, i32 2, i32 3, i32 4, i32 5]
; 外部函数声明
declare void @putint(i32)
declare void @putch(i32)
; main 函数
define i32 @main() {
entry:
    ; 局部变量初始化
    %sum = alloca i32
    %i = alloca i32
    %count = alloca i32
    
    store i32 0, ptr %sum        ; sum = 0
    store i32 0, ptr %i          ; i = 0
    store i32 5, ptr %count      ; count = 5
    
    br label %while_check

while_check:
    ; 检查循环条件: i < count
    %i_val = load i32, ptr %i
    %count_val = load i32, ptr %count
    %cmp = icmp slt i32 %i_val, %count_val
    br i1 %cmp, label %while_body, label %while_end

while_body:
    ; 循环体: sum = sum + global_array[i]
    %sum_val = load i32, ptr %sum
    %i_curr = load i32, ptr %i
    
    ; 计算 global_array[i] 的地址
    %array_ptr = getelementptr [5 x i32], ptr @global_array, i32 0, i32 %i_curr
    %array_val = load i32, ptr %array_ptr
    
    ; sum = sum + global_array[i]
    %new_sum = add i32 %sum_val, %array_val
    store i32 %new_sum, ptr %sum
    
    ; i = i + 1
    %new_i = add i32 %i_curr, 1
    store i32 %new_i, ptr %i
    
    br label %while_check

while_end:
    ; if (sum > 20)
    %final_sum = load i32, ptr %sum
    %if_cmp = icmp sgt i32 %final_sum, 20
    br i1 %if_cmp, label %then_branch, label %else_branch

then_branch:
    ; int result = calculate(sum, 2);
    %result = call i32 @calculate(i32 %final_sum, i32 2)
    
    ; putint(result); putch(10);
    call void @putint(i32 %result)
    call void @putch(i32 10)
    br label %exit

else_branch:
    ; int remainder = sum % 3;
    %remainder = srem i32 %final_sum, 3
    
    ; putint(remainder); putch(10);
    call void @putint(i32 %remainder)
    call void @putch(i32 10)
    br label %exit

exit:
    ret i32 0
}

; calculate 函数
define i32 @calculate(i32 %a, i32 %b) {
entry:
    ; 局部变量
    %result = alloca i32
    %b_local = alloca i32
    
    store i32 0, ptr %result     ; result = 0
    store i32 %b, ptr %b_local   ; 保存参数 b
    
    br label %loop_check

loop_check:
    ; 检查循环条件: b > 0
    %b_val = load i32, ptr %b_local
    %loop_cmp = icmp sgt i32 %b_val, 0
    br i1 %loop_cmp, label %loop_body, label %loop_end

loop_body:
    ; result = result + a
    %result_val = load i32, ptr %result
    %new_result = add i32 %result_val, %a
    store i32 %new_result, ptr %result
    
    ; b = b - 1
    %b_curr = load i32, ptr %b_local
    %new_b = sub i32 %b_curr, 1
    store i32 %new_b, ptr %b_local
    
    br label %loop_check

loop_end:
    %final_result = load i32, ptr %result
    ret i32 %final_result
}

\end{lstlisting}
\subsection{结果展示}
我们将上述SysY程序编译为ARM汇编，并链接运行时库，成功生成了可执行文件。以下是SysY程序和arm汇编的编译成功控制台信息：
\begin{lstlisting}[title=运行成功信息,frame=trbl]
yqq@LAPTOP-B4JFEDK6:~/repository/Copiler/1.编译器了解$ aarch64-linux-gnu-gcc test_aarch64.s lib.tar.gz/libsysy_aarch.a -o test_arm.out
yqq@LAPTOP-B4JFEDK6:~/repository/Copiler/1.编译器了解$ qemu-aarch64 -L /usr/aarch64-linux-gnu ./test_arm.out
1
TOTAL: 0H-0M-0S-0us
\end{lstlisting}
以下是llvm程序编译成功和运行的控制台信息：
\begin{lstlisting}[title=运行成功信息,frame=trbl]
enovo@wzs:~/lab1$ vim test3.ll
enovo@wzs:~/lab1$ clang test3.ll libsysy_x86.a -o my_ir_program3 -static
enovo@wzs:~/lab1$ ./my_ir_program3
1
TOTAL: 0H-0M-0S-0us
enovo@wzs:~/lab1$
\end{lstlisting}
\begin{table}[!htbp]
  \centering
\begin{tabular}{cccc}
        oprule
    array内容 & SysY编译输出 & arm汇编编译输出 & llvm IR编译输出 \\
    \midrule
    1,2,3,4,5 & 0 & 0 & 0 \\
    2,2,3,4,5 & 1 & 1 & 1 \\
    3,2,3,4,5 & 2 & 2 & 2 \\
    4,2,3,4,5 & 0 & 0 & 0 \\
    \bottomrule
\end{tabular}
  \caption{运行结果比较}
\end{table}
由此可见，SysY程序和llvm，arm汇编程序在相同输入下均能正确输出预期结果，功能实现一致。
\section{参考指令}
\begin{lstlisting}[language=text,caption={汇编指令}]
    gcc -E fibonacci.c -o fibonacci.i
    gcc -S fibonacci.i -o fibonacci.s
    gcc -c fibonacci.s -o fibonacci.o
    objdump -d fibonacci.o
    gcc fibonacci.o -o fibonacci
    objdump -d fibonacci > fibonacci.exe.asm
    ./fibonacci
    生成 token 流
    clang -Xclang -dump-tokens fibonacci.c
    # 生成 AST 
    clang -Xclang -ast-dump -fsyntax-only fibonacci.c > ast_dump.txt
    #生成符号表
    gcc -fdump-translation-unit fibonacci.c
    gcc -fdump-tree-all -O0 -c fibonacci.c -o fib_O0.o   # 无优化
    gcc -fdump-tree-all -O2 -c fibonacci.c -o fib_O2.o
    gcc -fdump-rtl-all fibonacci.c -O2 -o /dev/null
    # 编译llvm代码
    clang my_ir.ll libsysy_x86.a -o my_ir_program -static
\end{lstlisting}
% \newpage
% \bibliographystyle{plain}
% \bibliography{reference.bib} 

\end{document}